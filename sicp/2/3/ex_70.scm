(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))

(define (successive-merge pairs)
  (define (ordered-insert x set)
    (cond ((null? set) (list x))
          ((< (weight x) (weight (car set))) (cons x set))
          (else (cons (car set) (ordered-insert x (cdr set))))))
  (let ((first-pair (car pairs))
        (second-pair (cadr pairs))
        (tail (cddr pairs)))
    (let ((new-pair (make-code-tree first-pair second-pair)))
      (if (null? tail)
        new-pair
        (successive-merge (ordered-insert new-pair tail))))))

(define (make-leaf symbol weight)
  (list 'leaf symbol weight))
(define (leaf? object)
  (eq? (car object) 'leaf))
(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))

(define (make-code-tree left right)
  (list left
        right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))))

(define (left-branch tree) (car tree))
(define (right-branch tree) (cadr tree))
(define (symbols tree)
  (if (leaf? tree)
    (list (symbol-leaf tree))
    (caddr tree)))
(define (weight tree)
  (if (leaf? tree)
    (weight-leaf tree)
    (cadddr tree)))

(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
      '()
      (let ((next-branch
              (choose-branch (car bits) current-branch)))
        (if (leaf? next-branch)
          (cons (symbol-leaf next-branch)
                (decode-1 (cdr bits) tree))
          (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))
(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else (error "bad bit -- CHOOSE-BRANCH" bit))))

(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x) (weight (car set))) (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))
(define (make-leaf-set pairs)
  (if (null? pairs)
    '()
    (let ((pair (car pairs)))
      (adjoin-set (make-leaf (car pair)
                             (cadr pair))
                  (make-leaf-set (cdr pairs))))))

(define (encode message tree)
  (if (null? message)
    '()
    (append (encode-symbol (car message) tree)
            (encode (cdr message) tree)))))

(define (encode-symbol symbol tree)
  (define (symbol-in-list symbol l)
    (cond ((null? l) false)
          ((eq? symbol (car l)) true)
          (else (symbol-in-list symbol (cdr l)))))
  (if (leaf? tree)
    (if (not (eq? symbol (symbol-leaf tree)))
      (error "unexpected leaf -- ENCODE-SYMBOL" symbol tree)
      '())
    (cond ((symbol-in-list symbol (symbols (left-branch tree)))
           (cons 0 (encode-symbol symbol (left-branch tree))))
          ((symbol-in-list symbol (symbols (right-branch tree)))
           (cons 1 (encode-symbol symbol (right-branch tree))))
          (else (error "symbol not in tree -- ENCODE-SYMBOL" symbol)))))

(define t
  (generate-huffman-tree
    '((WAH 1) (BOOM 1) (GET 2) (A 2) (JOB 2) (SHA 3) (YIP 9) (NA 16))))
(display t)
(newline)
(define message
  (append
    '(GET A JOB)
    '(SHA NA NA NA NA NA NA NA NA)
    '(GET A JOB)
    '(SHA NA NA NA NA NA NA NA NA)
    '(WAH YIP YIP YIP YIP YIP YIP YIP YIP YIP)
    '(SHA BOOM)))
(display message)
(newline)
(define encoded (encode message t))
(display encoded)
(newline)
(display (decode encoded t))
(newline)
